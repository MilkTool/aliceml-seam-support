This is lightning.info, produced by makeinfo version 4.0 from
lightning.texi.

INFO-DIR-SECTION GNU lightning, a library for dynamic code generation
START-INFO-DIR-ENTRY
* Using and porting GNU lightning: (lightning).
END-INFO-DIR-ENTRY

   This file documents GNU lightning, Version 1.0.  It was last updated
on 2 November 2001.

   Copyright (C) 2000 Free Software Foundation, Inc.  Authored by Paolo
Bonzini.

   This document is released under the terms of the GNU Free
Documentation License as published by the Free Software Foundation;
either version 1.1, or (at your option) any later version.

   You should have received a copy of the GNU Free Documentation
License along with GNU lightning; see the file `COPYING.DOC'.  If not,
write to the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

   There are no Secondary Sections, no Cover Texts and no Invariant
Sections (as defined in the license); this text, along with its
equivalent in the printed manual, constitutes the Title Page.


File: lightning.info,  Node: Autoconf support,  Prev: Reentrancy,  Up: Using GNU lightning

Using `autoconf' with GNU lightning
===================================

   It is very easy to include GNU lightning's source code (without the
documentation and examples) into your program's distribution so so that
people don't need to have it installed in order to use it.

   Here is a step by step explanation of what to do:

  1. Execute this line from the main distribution directory
               make prepare TARGET=MAINDIR

     where MAINDIR is your package's main distribution directory.  If
     you're using Automake, you might be pleased to know that
     `Makefile.am' files will be already there.

  2. If you're not using Automake and `aclocal', instead, you should
     delete the `Makefile.am' files (they are of no use to you) and
     copy the contents of the `lightning.m4' file, found in GNU
     lightning's main distribution directory, to your `configure.in' or
     `acinclude.m4' or `aclocal.m4' file.(1)

  3. Include a call to the `LIGHTNING_CONFIGURE_IF_NOT_FOUND' macro in
     your `configure.in' file.

   `LIGHTNING_CONFIGURE_IF_NOT_FOUND' will first look for a
pre-installed copy of GNU lightning and, if it can be found, it will
use it; otherwise, it will do exactly the same things that GNU
lightning's own configure script does.  If GNU lightning is already
installed, or if the configuration process succeeds, it will define the
`HAVE_LIGHTNING' symbol.

   In addition, `LIGHTNING_CONFIGURE_IF_NOT_FOUND' accepts two optional
parameters: respectively, an action to be taken if GNU lightning is
available, and an action to be taken if it is not.

   ---------- Footnotes ----------

   (1) You might need to do that manually also if the `make install'
procedure could not write to `aclocal''s default macro directory.


File: lightning.info,  Node: Porting GNU lightning,  Next: Future,  Prev: Using GNU lightning,  Up: Top

Porting GNU lightning
*********************

   This chapter describes the process of porting GNU lightning.  It
assumes that you are pretty comfortable with the usage of GNU lightning
for dynamic code generation, as described in *Note Using GNU
lightning::.

* Menu:


* Structure of a port::   An overview of the porting process
* Adjusting configure::   Automatically recognizing the new platform
* Run-time assemblers::   An internal layer to simplify porting
* Standard macros::       The platform-independent layer used by clients.
* Standard functions::    Doing more complex tasks.
* Floating-point macros:: Implementing macros for floating point.


File: lightning.info,  Node: Structure of a port,  Next: Adjusting configure,  Up: Porting GNU lightning

An overview of the porting process
==================================

   A particular port of GNU lightning is composed of four files. These
have a common suffix which identifies the port (for example, `i386' or
`ppc'), and a prefix that identifies their function; they are:

   * `asm-SUFFIX.h', which contains the description of the target
     machine's instruction format.  The creation of this file is
     discussed in *Note Creating the run-time assembler: Run-time
     assemblers.

   * `core-SUFFIX.h', which contains the mappings from GNU lightning's
     instruction set to the target machine's assembly language format.
     The creation of this file is discussed in *Note Creating the
     platform-independent layer: Standard macros.

   * `funcs-SUFFIX.h', for now, only contains the definition of
     `jit_flush_code'. The creation of this file is briefly discussed
     in *Note More complex tasks in the platform-independent layer:
     Standard functions.

   * `fp-SUFFIX.h', which contains the description of the target
     machine's instruction format and the internal macros for doing
     floating point computation. The creation of this file is discussed
     in *Note Implementing macros for floating point: Floating-point
     macros.

   Before doing anything, you have to add the ability to recognize the
new port during the configuration process.  This is explained in *Note
Automatically recognizing the new platform: Adjusting configure.


File: lightning.info,  Node: Adjusting configure,  Next: Run-time assemblers,  Prev: Structure of a port,  Up: Porting GNU lightning

Automatically recognizing the new platform
==========================================

   Before starting your port, you have to add the ability to recognize
the new port during the configure process.  You only have to run
`config.guess', which you'll find in the main distribution directory,
and note down the first part of the output (up to the first dash).

   Then, in the two files `configure.in' and `lightning.m4', lookup the
line
         case "$host_cpu" in

and, right after it, add the line:
         CPU-NAME)  cpu=FILE-SUFFIX           ;;

where CPU-NAME is the cpu as output by `config.guess', and FILE-SUFFIX
is the suffix that you are going to use for your files (*note An
overview of the porting process: Structure of a port.).

   Now create empty files for your new port:
         touch lightning/asm-xxx.h
         touch lightning/fp-xxx.h
         touch lightning/core-xxx.h
         touch lightning/funcs-xxx.h

and run `configure', which should create the symlinks that are needed
by `lightning.h'.  This is important because it will allow you to use
GNU lightning (albeit in a limited way) for testing even before the
port is completed.


File: lightning.info,  Node: Run-time assemblers,  Next: Standard macros,  Prev: Adjusting configure,  Up: Porting GNU lightning

Creating the run-time assembler
===============================

   The run-time assembler is a set of macros whose purpose is to
assemble instructions for the target machine's assembly language,
translating mnemonics to machine language together with their operands.
While a run-time assembler is not, strictly speaking, part of GNU
lightning (it is a private layer to be used while implementing the
standard macros that are ultimately used by clients), designing a
run-time assembler first allows you to think in terms of assembly
language rather than binary code (ouch!...), making it considerably
easier to write the standard macros.

   Creating a run-time assembler is a tedious process rather than a
difficult one, because most of the time will be spent collecting and
copying information from the architecture's manual.

   Macros defined by a run-time assembler are conventionally named after
the mnemonic and the type of its operands.  Examples took from the
SPARC's run-time assembler are `ADDrrr', a macro that assembles an
`ADD' instruction with three register operands, and `SUBCCrir', which
assembles a `SUBCC' instruction whose second operand is an immediate
and the remaining two are registers.

   The first step in creating the assembler is to pick a convention for
operand specifiers (`r' and `i' in the example above) and for register
names.  On the SPARC, this convention is as follows

`r'
     A register name.  For every `r' in the macro name, a numeric
     parameter `RR' is passed to the macro, and the operand is assembled
     as `%rRR'.

`i'
     An immediate, usually a 13-bit signed integer (with exception for
     instructions such as `SETHI' and branches).  The macros check the
     size of the passed parameter if GNU lightning is configured with
     `--enable-assertions'.

`x'
     A combination of two `r' parameters, which are summed to determine
     the effective address in a memory load/store operation.

`m'
     A combination of an `r' and `i' parameter, which are summed to
     determine the effective address in a memory load/store operation.

   Additional macros can be defined that provide easier access to
register names.  For example, on the SPARC, `_Ro(3)' and `_Rg(5)' map
respectively to `%o3' and `%g5'; on the x86, instead, symbolic
representations of the register names are provided (for example, `_EAX'
and `_EBX').

   CISC architectures sometimes have registers of different sizes-this
is the case on the x86 where `%ax' is a 16-bit register while `%esp' is
a 32-bit one.  In this case, it can be useful to embed information on
the size in the definition of register names.  The x86 machine
language, for example, represents all three of `%bh', `%di' and `%edi'
as 7; but the x86 run-time assemblers defines them with different
numbers, putting the register's size in the upper nybble (for example,
`17h' for `%bh' and `27h' for `%di') so that consistency checks can be
made on the operands' sizes when `--enable-assertions' is used.

   The next important part defines the native architecture's instruction
formats.  These can be as few as ten on RISC architectures, and as many
as fifty on CISC architectures.  In the latter case it can be useful to
define more macros for sub-formats (such as macros for different
addressing modes) or even for sub-fields in an instruction.  Let's see
an example of these macros.

     #define _2i( OP, RD, OP2, IMM)
             _I((_u2 (OP )<<30)  |  (_u5(RD)<<25)  |  (_u3(OP2)<<22)  |
                 _u22(IMM)                                            )

   The name of the macro, `_2i', indicates a two-operand instruction
comprising an immediate operand.  The instruction format is:

      .------.---------.------.-------------------------------------------.
      |  OP  |   RD    | OP2  |               IMM                         |
      |------+---------+------+-------------------------------------------|
      |2 bits|  5 bits |3 bits|             22 bits                       |
      |31-30 |  29-25  | 22-24|              0-21                         |
      '------'---------'------'-------------------------------------------'

   GNU lightning provides macros named `_sXX(OP)' and `_uXX(OP)', where
XX is a number between 1 and 31, which test(1) whether `OP' can be
represented as (respectively) a signed or unsigned integer of the given
size.  What the macro above does, then, is to shift and OR together the
different fields, ensuring that each of them fits the field.

   Here is another definition, this time for the PowerPC architecture.

     #define _X(OP,RD,RA,RB,XO,RC)
             _I((_u6 (OP)<<26)  |  (_u5(RD)<<21)  |  (_u5(RA)<<16)  |
                ( _u5(RB)<<11)  |  (_u10(XO)<<1)  |   _u1(RC)       )

   Here is the bit layout corresponding to this instruction format:

      .--------.--------.--------.--------.---------------------.-------.
      |    OP  |   RD   |   RA   |   RB   |           X0        |   RC  |
      |--------+--------+--------+--------+-----------------------------|
      | 6 bits | 5 bits | 5 bits | 5 bits |         10 bits     | 1 bit |
      | 31-26  | 25-21  | 16-20  | 11-15  |         1-10        |   0   |
      '--------'---------'-------'--------'-----------------------------'

   How do these macros actually generate code? The secret lies in the
`_I' macro, which is one of four predefined macros which actually store
machine language instructions in memory.  They are `_B', `_W', `_I' and
`_L', respectively for 8-bit, 16-bit, 32-bit, and `long' (either 32-bit
or 64-bit, depending on the architecture) values.

   Next comes another set of macros (usually the biggest) which
represents the actual mnemonics--macros such as `ADDrrr' and `SUBCCrir',
which were cited earlier in this chapter, belong to this set.  Most of
the times, all these macros will do is to use the "instruction format"
macros, specifying the values of the fields in the different instruction
formats.  Let's see a few of these definitions, again taken from the
SPARC assembler:

     #define BAi(DISP)                       _2   (0, 0,  8, 2, DISP)
     #define BA_Ai(DISP)                     _2   (0, 1,  8, 2, DISP)
     
     #define SETHIir(IMM, RD)                _2i  (0, RD, 4, IMM)
     
     #define ADDrrr(RS1, RS2, RD)            _3   (2, RD,  0, RS1, 0, 0, RS2)
     #define ADDrir(RS1, IMM, RD)            _3i  (2, RD,  0, RS1, 1,    IMM)
     #define ADDCCrrr(RS1, RS2, RD)          _3   (2, RD, 16, RS1, 0, 0, RS2)
     #define ADDCCrir(RS1, IMM, RD)          _3i  (2, RD, 16, RS1, 1,    IMM)
     #define ANDrrr(RS1, RS2, RD)            _3   (2, RD,  1, RS1, 0, 0, RS2)
     #define ANDrir(RS1, IMM, RD)            _3i  (2, RD,  1, RS1, 1,    IMM)
     #define ANDCCrrr(RS1, RS2, RD)          _3   (2, RD, 17, RS1, 0, 0, RS2)
     #define ANDCCrir(RS1, IMM, RD)          _3i  (2, RD, 17, RS1, 1,    IMM)

   A few things have to be noted.  For example:
   * The SPARC assembly language sometimes uses a comma inside a
     mnemonic (for example, `ba,a').  This symbol is not allowed inside
     a CPP macro name, so it is replaced with an underscore; the same
     is done with the dots found in the PowerPC assembly language (for
     example, `andi.' is defined as `ANDI_rri').

   * It can be useful to group together instructions with the same
     instruction format, as doing this tends to make the source code
     more readable (numbers are put in the same columns).

   * Using an editor without automatic wrap at end of line can be
     useful, since run-time assemblers tend to have very long lines.

   A final touch is to define the synthetic instructions, which are
usually found on RISC machines.  For example, on the SPARC, the `LD'
instruction has two synonyms (`LDUW' and `LDSW') which are defined thus:

     #define LDUWxr(RS1, RS2, RD)            LDxr(RS1, RS2, RD)
     #define LDUWmr(RS1, IMM, RD)            LDmr(RS1, IMM, RD)
     #define LDSWxr(RS1, RS2, RD)            LDxr(RS1, RS2, RD)
     #define LDSWmr(RS1, IMM, RD)            LDmr(RS1, IMM, RD)

   Other common case are instructions which take advantage of registers
whose value is hard-wired to zero, and short-cut instructions which
hard-code some or all of the operands:

     /* Destination is %g0, which the processor never overwrites. */
     #define CMPrr(R1, R2)   SUBCCrrr(R1, R2, 0) /* subcc %r1, %r2, %g0 */
     
     /* One of the source registers is hard-coded to be %g0. */
     #define NEGrr(R,S)      SUBrrr(0, R, S)     /* sub %g0, %rR, %rS */
     
     /* All of the operands are hard-coded. */
     #define RET()           JMPLmr(31,8 ,0)     /* jmpl [%r31+8], %g0  */
     
     /* One of the operands acts as both source and destination */
     #define BSETrr(R,S)     ORrrr(R, S, S)      /* or %rR, %rS, %rS */

   Specific to RISC computers, finally, is the instruction to load an
arbitrarily sized immediate into a register.  This instruction is
usually implemented as one or two basic instructions:

  1. If the number is small enough, an instruction is sufficient (`LI'
     or `ORI' on the PowerPC, `MOV' on the SPARC).

  2. If the lowest bits are all zeroed, an instruction is sufficient
     (`LIS' on the PowerPC, `SETHI' on the SPARC).

  3. Otherwise, the high bits are set first (with `LIS' or `SETHI'),
     and the result is then ORed with the low bits

   Here is the definition of such an instruction for the PowerPC:

     #define MOVEIri(R,I)      (_siP(16,I) ? LIri(R,I) :     \ /* case 1    */
                               (_uiP(16,I) ? ORIrri(R,0,I) : \ /* case 1    */
                               _MOVEIri(R, _HI(I), _LO(I)) ))  /* case 2/3  */
     
     #define _MOVEIri(H,L,R)  (LISri(R,H), (L ? ORIrri(R,R,L) : 0))

and for the SPARC:

     #define SETir(I,R)      (_siP(13,I) ? MOVir(I,R) : \
     			 _SETir(_HI(I), _LO(I), R))
     
     #define _SETir(H,L,R)   (SETHIir(H,R), (L ? ORrir(R,L,R) : 0))

   In both cases, `_HI' and `_LO' are macros for internal use that
extract different parts of the immediate operand.

   You should take a look at the run-time assemblers distributed with
GNU lightning before trying to craft your own.  In particular, make
sure you understand the RISC run-time assemblers (the SPARC's is the
simplest) before trying to decypher the x86 run-time assembler, which
is significantly more complex.

   ---------- Footnotes ----------

   (1) Only when `--enable-assertions' is used.


File: lightning.info,  Node: Standard macros,  Next: Standard functions,  Prev: Run-time assemblers,  Up: Porting GNU lightning

Creating the platform-independent layer
=======================================

   The platform-independent layer is the one that is ultimately used by
GNU lightning clients.  Creating this layer is a matter of creating a
hundred or so macros that comprise part of the interface used by the
clients, as described in *Note GNU lightning's instruction set: The
instruction set.

   Fortunately, a number of these definitions are common to the
different platforms and are defined just once in one of the header
files that make up GNU lightning, that is, `core-common.h'.

   Most of the macros are relatively straight-forward to implement (with
a few caveats for architectures whose assembly language only offers
two-operand arithmetic instructions).  This section will cover the
tricky points, before presenting the complete listing of the macros
that make up the platform-independent interface provided by GNU
lightning.

* Menu:

* Forward references::    Implementing forward references
* Common features::       Common features supported by `core-common.h'
* Delay slots::           Supporting scheduling of delay slots
* Immediate values::      Supporting arbitrarily sized immediate values
* Implementing the ABI::  Function prologs and epilogs, and argument passing
* Macro list::            Macros composing the platform-independent layer


File: lightning.info,  Node: Forward references,  Next: Common features,  Up: Standard macros

Implementing forward references
-------------------------------

   Implementation of forward references takes place in:

   * The branch macros

   * The `jit_patch' macros

   Roughly speaking, the branch macros, as seen in *Note Generating
code at run-time: GNU lightning macros, return a value that later calls
to `jit_patch' use to complete the assembly of the forward reference.
This value is usually the contents of the program counter after the
branch instruction is compiled (which is accessible in the `_jit.pc'
variable).  Let's see an example from the x86 back-end:

     #define jit_bmsr_i(label, s1, s2)                            \
        (TESTLrr((s1), (s2)), JNZm(label,0,0,0), _jit.pc)

   The `bms' ("branch if mask set") instruction is assembled as the
combination of a `TEST' instruction (bit-wise AND between the two
operands) and a `JNZ' instruction (jump if non-zero).  The macro then
returns the final value of the program counter.

   `jit_patch' is one of the few macros that need to possess a
knowledge of the machine's instruction formats.  Its purpose is to
patch a branch instruction (identified by the value returned at the
moment the branch was compiled) to jump to the current position (that
is, to the address identified by `_jit.pc').

   On the x86, the displacement between the jump and the landing point
is expressed as a 32-bit signed integer lying in the last four bytes of
the jump instruction.  The definition of `_jit_patch' is:

     #define jit_patch(jump_pc)      (*_PSL((jump_pc) - 4) = \
     				  _jit.pc - (jump_pc))

   The `_PSL' macro is nothing more than a cast to `long *', and is
used here to shorten the definition and avoid cluttering it with
excessive parentheses.  These type-cast macros are:

   * `_PUC(X)' to cast to a `unsigned char *'.

   * `_PUS(X)' to cast to a `unsigned short *'.

   * `_PUI(X)' to cast to a `unsigned int *'.

   * `_PSL(X)' to cast to a `long *'.

   * `_PUL(X)' to cast to a `unsigned long *'.

   On other platforms, notably RISC ones, the displacement is embedded
into the instruction itself.  In this case, `jit_patch' must first zero
out the field, and then OR in the correct displacement.  The SPARC, for
example, encodes the displacement in the bottom 22 bits; in addition
the right-most two bits are suppressed, which are always zero because
instruction have to be word-aligned.

     #define jit_patch(delay_pc)   jit_patch_ ( ((delay_pc) - 1) )
     
     /* branch instructions return the address of the _delay_
      * instruction--this is just a helper macro that makes the code more
      * readable.
      */
     #define jit_patch_(jump_pc)   (*jump_pc =		    \
     	 (*jump_pc & ~_MASK(22)) |			    \
              ((_UL(_jit.pc) - _UL(jump_pc)) >> 2) & _MASK(22))

   This introduces more predefined shortcut macros:
   * `_UC(X)' to cast to a `unsigned char'.

   * `_US(X)' to cast to a `unsigned short'.

   * `_UI(X)' to cast to a `unsigned int'.

   * `_SL(X)' to cast to a `long'.

   * `_UL(X)' to cast to a `unsigned long'.

   * `_MASK(N)' gives a binary number made of N ones.


File: lightning.info,  Node: Common features,  Next: Delay slots,  Prev: Forward references,  Up: Standard macros

Common features supported by `core-common.h'
--------------------------------------------

   The `core-common.h' file contains hundreds of macro definitions
which will spare you defining a lot of things in the files the are
specific to your port.  Here is a list of the features that
`core-common.h' provides.

Support for common synthetic instructions
     These are instructions that can be represented as a simple
     operation, for example a bit-wise AND or a subtraction.
     `core-common.h' recognizes when the port-specific header file
     defines these macros and avoids compiler warnings about redefined
     macros, but there should be no need to define them.  They are:
          #define jit_extr_c_ui(d, rs)
          #define jit_extr_i_ul(d, rs)
          #define jit_extr_s_ui(d, rs)
          #define jit_negr_i(d, rs)
          #define jit_negr_l(d, rs)

Support for the ABI
     Both `jit_prolog', `jit_leaf' and `jit_finish' are not mandatory.
     If not defined, they will be defined respectively as an empty
     macro, as a synonym for `jit_prolog', and as a synonym for
     `jit_calli'.  Whether to define them or not in the port-specific
     header file, it depends on the underlying architecture's ABI--in
     general, however, you'll need to define at least `jit_prolog'.

Support for uncommon instructions
     These are instructions that many widespread architectures lack.
     `core-common.h' is able to provide default definitions, but they
     are usually inefficient if the hardware provides a way to do these
     operations with a single instruction.  They are extension with sign
     and "reverse subtraction" (that is, REG2=IMM-REG1):
          #define jit_extr_c_i(d, rs)
          #define jit_extr_s_i(d, rs)
          #define jit_rsbi_i(d, rs, is)
          #define jit_rsbi_l(d, rs, is)

Conversion between network and host byte ordering
     These macros are no-ops on big endian systems.  Don't define them
     on such systems; on the other hand, they are mandatory on little
     endian systems.  They are:
          #define jit_ntoh_ui(d, rs)
          #define jit_ntoh_us(d, rs)

Support for a "zero" register
     Many RISC architectures provide a read-only register whose value is
     hard-coded to be zero; this register is then used implicitly when
     referring to a memory location using a single register.  For
     example, on the SPARC, an operand like `[%l6]' is actually
     assembled as `[%l6+%g0]'.  If this is the case, you should define
     `JIT_RZERO' to be the number of this register; `core-common.h'
     will use it to implement all variations of the `ld' and `st'
     instructions.  For example:
          #define jit_ldi_c(d, is)         jit_ldxi_c(d, JIT_RZERO, is)
          #define jit_ldr_i(d, rs)         jit_ldxr_c(d, JIT_RZERO, rs)

     If available, JIT_RZERO is also used to provide more efficient
     definitions of the `neg' instruction (see "Support for common
     synthetic instructions", above).

Synonyms
     `core-common.h' provides a lot of trivial definitions which make
     the instruction set as orthogonal as possible.  For example,
     adding two unsigned integers is exactly the same as adding two
     signed integers (assuming a two's complement representation of
     negative numbers); yet, GNU lightning provides both `jit_addr_i'
     and `jit_addr_ui' macros.  Similarly, pointers and unsigned long
     integers behave in the same way, but GNU lightning has separate
     instruction for the two data types--those that operate on pointers
     usually comprise a typecast that makes programs clearer.

Shortcuts
     These define "synthetic" instructions whose definition is not as
     trivial as in the case of synonyms, but is anyway standard.  This
     is the case for bitwise NOT (which is implemented by XORing a
     string of ones), "reverse subtraction" between registers (which is
     converted to a normal subtraction with the two source operands
     inverted), and subtraction of an immediate from a register (which
     is converted to an addition).  Unlike `neg' and `ext' (see
     "Support for common synthetic instructions", above), which are
     simply non-mandatory, you must not define these functions.

Support for `long's
     On most systems, `long's and `unsigned long's are the same as,
     respectively, `int's and `unsigned int's.  In this case,
     `core-common.h' defines operations on these types to be synonyms.

`jit_state'
     Last but not least, `core-common.h' defines the `jit_state' type.
     Part of this `struct' is machine-dependent and includes all kinds
     of state needed by the back-end; this part is always accessible in
     a re-entrant way as `_jitl'.  `_jitl' will be of type `struct
     jit_local_state'; this struct must be defined even if no state is
     required.


File: lightning.info,  Node: Delay slots,  Next: Immediate values,  Prev: Common features,  Up: Standard macros

Supporting scheduling of delay slots
------------------------------------

   Delay slot scheduling is obtained by clients through the `jit_delay'
macro.  However this macro is not to be defined in the
platform-independent layer, because GNU lightning provides a common
definition in `core-common.h'.

   Instead, the platform-independent layer must define another macro,
called `jit_fill_delay_after', which has to exchange the instruction to
be scheduled in the delay slot with the branch instruction.  The only
parameter accepted by the macro is a call to a branch macro, which must
be expanded *exactly once* by `jit_fill_delay_after'.  The client must
be able to pass the return value of `jit_fill_delay_after' to
`jit_patch'.

   There are two possible approaches that can be used in
`jit_fill_delay_after'.  They are summarized in the following pictures:

   * The branch instructions assemble a NOP instruction which is then
     removed by `jit_fill_delay_after'.

               before                         |   after
             ---------------------------------+-----------------------------
               ...                            |
               <would-be delay instruction>   |    <branch instruction>
               <branch instruction>           |    <delay instruction>
               NOP                            |           <--- _jit.pc
                        <--- _jit.pc          |

   * The branch instruction assembles the branch so that the delay slot
     is annulled, `jit_fill_delay_after' toggles the bit:

               before                         |   after
             ---------------------------------+-----------------------------
               ...                            |
               <would-be delay instruction>   |    <branch instruction>
               <branch with annulled delay>   |    <delay instruction>
                        <--- _jit.pc          |           <--- _jit.pc

   Don't forget that you can take advantage of delay slots in the
implementation of boolean instructions such as `le' or `gt'.


File: lightning.info,  Node: Immediate values,  Next: Implementing the ABI,  Prev: Delay slots,  Up: Standard macros

Supporting arbitrarily sized immediate values
---------------------------------------------

   This is a problem that is endemic to RISC machines.  The basic idea
is to reserve one or two register to represent large immediate values.
Let's see an example from the SPARC:

        addi_i R0, V2, 45         |  addi_i R0, V2, 10000
       ---------------------------+---------------------------
        add    %l5, 45, %l0       |  set    10000, %l6
                                  |  add    %l5, %l6, %l0

   In this case, `%l6' is reserved to be used for large immediates.  An
elegant solution is to use an internal macro which automatically
decides which version is to be compiled.

   Beware of register conflicts on machines with delay slots.  This is
the case for the SPARC, where `%l7' is used instead for large
immediates in compare-and-branch instructions.  So the sequence

        jit_delay(
           jit_addi_i(JIT_R0, JIT_V2, 10000),
           jit_blei_i(label, JIT_R1, 20000)
        );

is assembled this way:

        set 10000, %l6       ! prepare immediate for add
        set 20000, %l7       ! prepare immediate for cmp
        cmp %l1, %l7
        ble label
        add %l5, %l6, %l0    ! delay slot
     	

   Note that using `%l6' in the branch instruction would have given an
incorrect result--`R0' would have been filled with the value of
`V2+20000' rather than `V2+10000'.


File: lightning.info,  Node: Implementing the ABI,  Next: Macro list,  Prev: Immediate values,  Up: Standard macros

Implementing the ABI
--------------------

   Implementing the underlying architecture's ABI is done in the macros
that handle function prologs and epilogs and argument passing.

   Let's look at the prologs and epilogs first.  These are usually
pretty simple and, what's more important, with constant content--that
is, they always generate exactly the same instruction sequence.  Here is
an example:

               SPARC                        x86
               save %sp, -96, %sp           push %ebp
                                            push %ebx
                                            push %esi
                                            push %edi
                                            movl %esp, %ebp
               ...                          ...
               ret                          popl %edi
               restore                      popl %esi
                                            popl %ebx
                                            popl %ebp
                                            ret

   The registers that are saved (`%ebx', `%esi', `%edi') are mapped to
the `V0' through `V2' registers in the GNU lightning instruction set.

   Argument passing is more tricky.  There are basically three cases(1):
Register windows
     Output registers are different from input registers--the prolog
     takes care of moving the caller's output registers to the callee's
     input registers.  This is the case with the SPARC.

Passing parameters via registers
     In this case, output registers are the same as input registers.
     The program must take care of saving input parameters somewhere
     (on the stack, or in non-argument registers).  This is the case
     with the PowerPC.

All the parameters are passed on the stack
     This case is by far the simplest and is the most common in CISC
     architectures, like the x86 and Motorola 68000.

   In all cases, the port-specific header file will define two variable
for private use--one to be used by the caller during the
`prepare'/`pusharg'/`finish' sequence, one to be used by the callee,
specifically in the `jit_prolog' and `jit_arg' macros.

   Let's look again, this time with more detail, at each of the cases.

Register windows
     `jit_finish' is the same as `jit_calli', and is defined in
     `core-common.h' (*note Common features supported by
     `core-common.h': Common features.).

          #define jit_prepare(numargs)  (_jitl.pusharg = _Ro(numargs))
          #define jit_pusharg_i(rs)     (--_jitl.pusharg,         \
                                         MOVrr((rs), _jitl.pusharg))

     Remember that arguments pushing takes place in reverse order, thus
     giving a pre-decrement (rather than post-increment) in
     `jit_pusharg_i'.

     Here is what happens on the callee's side:

          #define jit_arg_c()           (_jitl.getarg++)
          #define jit_getarg_c(rd, ofs) jit_extr_c_i  ((rd), (ofs))
          #define jit_prolog(numargs)   (SAVErir(JIT_SP, -96, JIT_SP), \
                                         _jitl.getarg = _Ri(0))

     The `jit_arg' macros return nothing more than a register index,
     which is then used by the `jit_getarg' macros.  `jit_prolog'
     resets the counter used by `jit_arg' to zero; the `numargs'
     parameter is not used. It is sufficient for `jit_leaf' to be a
     synonym for `jit_prolog'.

Passing parameter via registers
     The code is almost the same as that for the register windows case,
     but with an additional complexity--`jit_arg' will transfer the
     argument from the input register to a non-argument register so that
     function calls will not clobber it.  The prolog and epilog code
     can then become unbearably long, up to 20 instructions on the PPC;
     a common solution in this case is that of "trampolines".

     The prolog does nothing more than put the function's actual
     address in a caller-preserved register and then call the
     trampoline:
                 mflr    r0                 ! grab return address
                 movei   r10, trampo_2args  ! jump to trampoline
                 mtlr    r10
                 blrl
          here:  mflr    r31                ! r31 = address of epilog
                 ...actual code...
                 mtlr    r31                ! return to the trampoline
                 blr

     In this case, `jit_prolog' does use its argument containing the
     number of parameters to pick the appropriate trampoline. Here,
     `trampo_2args' is the address of a trampoline designed for
     2-argument functions.

     The trampoline executes the prolog code, jumps to the contents of
     `r10', and upon return from the subroutine it executes the epilog
     code.

All the parameters are passed on the stack
     `jit_pusharg' uses a hardware push operation, which is commonly
     available on CISC machines (where this approach is most likely
     followed).  Since the stack has to be cleaned up after the call,
     `jit_prepare' remembers how many parameters have been put there,
     and `jit_finish' adjusts the stack pointer after the call.

          #define jit_prepare(numargs) (_jitl.args += (numargs))
          #define jit_pusharg_i(rs)    PUSHLr(rs)
          #define jit_finish(sub)      (jit_calli((sub)),              \
                                       ADDLir(4 * _jitl.args, JIT_SP), \
                                       _jitl.numargs = 0)

     Note the usage of `+=' in `jit_prepare'.  This is done so that one
     can defer the popping of the arguments that were saved on the
     stack ("stack pollution").  To do so, it is sufficient to use
     `jit_calli' instead of `jit_finish' in all but the last call.

     On the caller's side, `arg' returns an offset relative to the
     frame pointer, and `getarg' loads the argument from the stack:

          #define jit_getarg_c(rd, ofs) jit_ldxi_c((rd), _EBP, (ofs));
          #define jit_arg_c()           ((_jitl.frame += sizeof(int) \
                                                      -  sizeof(int))

     The `_jitl.frame' variable is initialized by `jit_prolog' with the
     displacement between the value of the frame pointer (`%ebp') and
     the address of the first parameter.

   These schemes are the most used, so `core-common.h' provides a way
to employ them automatically.  If you do not define the `jit_getarg_c'
macro and its companions, `core-common.h' will presume that you intend
to pass parameters through either the registers or the stack.

   If you define `JIT_FP', stack-based parameter passing will be
employed and the `jit_getarg' macros will be defined like this:

     #define jit_getarg_c(reg, ofs)  jit_ldxi_c((reg), JIT_FP, (ofs));

   In other words, the `jit_arg' macros (which are still to be defined
by the platform-specific back-end) shall return an offset into the stack
frame.  On the other hand, if you don't define `JIT_FP', register-based
parameter passing will be employed and the `jit_arg' macros shall
return a register number; in this case, `jit_getarg' will be
implemented in terms of `jit_extr' and `jit_movr' operations:

     #define jit_getarg_c(reg, ofs)		jit_extr_c_i  ((reg), (ofs))
     #define jit_getarg_i(reg, ofs)		jit_movr_i    ((reg), (ofs))

   ---------- Footnotes ----------

   (1) For speed and ease of implementation, GNU lightning does not
currently support passing some of the parameters on the stack and some
in registers.

