This is lightning.info, produced by makeinfo version 4.0 from
lightning.texi.

INFO-DIR-SECTION GNU lightning, a library for dynamic code generation
START-INFO-DIR-ENTRY
* Using and porting GNU lightning: (lightning).
END-INFO-DIR-ENTRY

   This file documents GNU lightning, Version 1.0.  It was last updated
on 2 November 2001.

   Copyright (C) 2000 Free Software Foundation, Inc.  Authored by Paolo
Bonzini.

   This document is released under the terms of the GNU Free
Documentation License as published by the Free Software Foundation;
either version 1.1, or (at your option) any later version.

   You should have received a copy of the GNU Free Documentation
License along with GNU lightning; see the file `COPYING.DOC'.  If not,
write to the Free Software Foundation, 59 Temple Place - Suite 330,
Boston, MA 02111-1307, USA.

   There are no Secondary Sections, no Cover Texts and no Invariant
Sections (as defined in the license); this text, along with its
equivalent in the printed manual, constitutes the Title Page.


File: lightning.info,  Node: Macro list,  Prev: Implementing the ABI,  Up: Standard macros

Macros composing the platform-independent layer
-----------------------------------------------

Register names (all mandatory but the last two)
          #define JIT_R0
          #define JIT_R1
          #define JIT_R2
          #define JIT_V0
          #define JIT_V1
          #define JIT_V2
          #define JIT_SP
          #define JIT_FP
          #define JIT_RZERO

Helper macros (non-mandatory):
          #define jit_fill_delay_after(branch)

Mandatory:
          #define jit_arg_c()
          #define jit_arg_i()
          #define jit_arg_l()
          #define jit_arg_p()
          #define jit_arg_s()
          #define jit_arg_uc()
          #define jit_arg_ui()
          #define jit_arg_ul()
          #define jit_arg_us()
          #define jit_addi_i(d, rs, is)
          #define jit_addr_i(d, s1, s2)
          #define jit_addxi_i(d, rs, is)
          #define jit_addxr_i(d, s1, s2)
          #define jit_andi_i(d, rs, is)
          #define jit_andr_i(d, s1, s2)
          #define jit_beqi_i(label, rs, is)
          #define jit_beqr_i(label, s1, s2)
          #define jit_bgei_i(label, rs, is)
          #define jit_bgei_ui(label, rs, is)
          #define jit_bger_i(label, s1, s2)
          #define jit_bger_ui(label, s1, s2)
          #define jit_bgti_i(label, rs, is)
          #define jit_bgti_ui(label, rs, is)
          #define jit_bgtr_i(label, s1, s2)
          #define jit_bgtr_ui(label, s1, s2)
          #define jit_blei_i(label, rs, is)
          #define jit_blei_ui(label, rs, is)
          #define jit_bler_i(label, s1, s2)
          #define jit_bler_ui(label, s1, s2)
          #define jit_blti_i(label, rs, is)
          #define jit_blti_ui(label, rs, is)
          #define jit_bltr_i(label, s1, s2)
          #define jit_bltr_ui(label, s1, s2)
          #define jit_boaddi_i(label, rs, is)
          #define jit_boaddi_ui(label, rs, is)
          #define jit_boaddr_i(label, s1, s2)
          #define jit_boaddr_ui(label, s1, s2)
          #define jit_bosubi_i(label, rs, is)
          #define jit_bosubi_ui(label, rs, is)
          #define jit_bosubr_i(label, s1, s2)
          #define jit_bosubr_ui(label, s1, s2)
          #define jit_bmci_i(label, rs, is)
          #define jit_bmcr_i(label, s1, s2)
          #define jit_bmsi_i(label, rs, is)
          #define jit_bmsr_i(label, s1, s2)
          #define jit_bnei_i(label, rs, is)
          #define jit_bner_i(label, s1, s2)
          #define jit_calli(label)
          #define jit_divi_i(d, rs, is)
          #define jit_divi_ui(d, rs, is)
          #define jit_divr_i(d, s1, s2)
          #define jit_divr_ui(d, s1, s2)
          #define jit_eqi_i(d, rs, is)
          #define jit_eqr_i(d, s1, s2)
          #define jit_gei_i(d, rs, is)
          #define jit_gei_ui(d, s1, s2)
          #define jit_ger_i(d, s1, s2)
          #define jit_ger_ui(d, s1, s2)
          #define jit_gti_i(d, rs, is)
          #define jit_gti_ui(d, s1, s2)
          #define jit_gtr_i(d, s1, s2)
          #define jit_gtr_ui(d, s1, s2)
          #define jit_hmuli_i(d, rs, is)
          #define jit_hmuli_ui(d, rs, is)
          #define jit_hmulr_i(d, s1, s2)
          #define jit_hmulr_ui(d, s1, s2)
          #define jit_jmpi(label)
          #define jit_jmpr(reg)
          #define jit_ldxi_c(d, rs, is)
          #define jit_ldxi_i(d, rs, is)
          #define jit_ldxi_s(d, rs, is)
          #define jit_ldxi_uc(d, rs, is)
          #define jit_ldxi_us(d, rs, is)
          #define jit_ldxr_c(d, s1, s2)
          #define jit_ldxr_i(d, s1, s2)
          #define jit_ldxr_s(d, s1, s2)
          #define jit_ldxr_uc(d, s1, s2)
          #define jit_ldxr_us(d, s1, s2)
          #define jit_lei_i(d, rs, is)
          #define jit_lei_ui(d, s1, s2)
          #define jit_ler_i(d, s1, s2)
          #define jit_ler_ui(d, s1, s2)
          #define jit_lshi_i(d, rs, is)
          #define jit_lshr_i(d, r1, r2)
          #define jit_lti_i(d, rs, is)
          #define jit_lti_ui(d, s1, s2)
          #define jit_ltr_i(d, s1, s2)
          #define jit_ltr_ui(d, s1, s2)
          #define jit_modi_i(d, rs, is)
          #define jit_modi_ui(d, rs, is)
          #define jit_modr_i(d, s1, s2)
          #define jit_modr_ui(d, s1, s2)
          #define jit_movi_i(d, is)
          #define jit_movr_i(d, rs)
          #define jit_muli_i(d, rs, is)
          #define jit_muli_ui(d, rs, is)
          #define jit_mulr_i(d, s1, s2)
          #define jit_mulr_ui(d, s1, s2)
          #define jit_nei_i(d, rs, is)
          #define jit_ner_i(d, s1, s2)
          #define jit_nop()
          #define jit_ori_i(d, rs, is)
          #define jit_orr_i(d, s1, s2)
          #define jit_patch(jump_pc)
          #define jit_pop_i(rs)
          #define jit_prepare(numargs)
          #define jit_push_i(rs)
          #define jit_pusharg_i(rs)
          #define jit_ret()
          #define jit_retval_i(rd)
          #define jit_rshi_i(d, rs, is)
          #define jit_rshi_ui(d, rs, is)
          #define jit_rshr_i(d, r1, r2)
          #define jit_rshr_ui(d, r1, r2)
          #define jit_stxi_c(rd, id, rs)
          #define jit_stxi_i(rd, id, rs)
          #define jit_stxi_s(rd, id, rs)
          #define jit_stxr_c(d1, d2, rs)
          #define jit_stxr_i(d1, d2, rs)
          #define jit_stxr_s(d1, d2, rs)
          #define jit_subr_i(d, s1, s2)
          #define jit_subxi_i(d, rs, is)
          #define jit_subxr_i(d, s1, s2)
          #define jit_xori_i(d, rs, is)
          #define jit_xorr_i(d, s1, s2)

Non mandatory--there should be no need to define them:
          #define jit_extr_c_ui(d, rs)
          #define jit_extr_i_ul(d, rs)
          #define jit_extr_s_ui(d, rs)
          #define jit_negr_i(d, rs)
          #define jit_negr_l(d, rs)

Non mandatory--whether to define them depends on the ABI:
          #define jit_prolog()
          #define jit_finish()
          #define jit_leaf()
          #define jit_getarg_c(reg, ofs)
          #define jit_getarg_i(reg, ofs)
          #define jit_getarg_l(reg, ofs)
          #define jit_getarg_p(reg, ofs)
          #define jit_getarg_s(reg, ofs)
          #define jit_getarg_uc(reg, ofs)
          #define jit_getarg_ui(reg, ofs)
          #define jit_getarg_ul(reg, ofs)
          #define jit_getarg_us(reg, ofs)

Non mandatory--define them if instructions that do this exist:
          #define jit_extr_c_i(d, rs)
          #define jit_extr_s_i(d, rs)
          #define jit_rsbi_i(d, rs, is)
          #define jit_rsbi_l(d, rs, is)

Non mandatory if condition code are always set by add/sub, needed on other systems:
          #define jit_addci_i(d, rs, is)
          #define jit_addci_l(d, rs, is)
          #define jit_subci_i(d, rs, is)
          #define jit_subci_l(d, rs, is)

Mandatory on little endian systems--don't define them on other systems:
          #define jit_ntoh_ui(d, rs)
          #define jit_ntoh_us(d, rs)

Mandatory if JIT_RZERO not defined--don't define them if it is defined:
          #define jit_ldi_c(d, is)
          #define jit_ldi_i(d, is)
          #define jit_ldi_s(d, is)
          #define jit_ldr_c(d, rs)
          #define jit_ldr_i(d, rs)
          #define jit_ldr_s(d, rs)
          #define jit_ldi_uc(d, is)
          #define jit_ldi_ui(d, is)
          #define jit_ldi_ul(d, is)
          #define jit_ldi_us(d, is)
          #define jit_ldr_uc(d, rs)
          #define jit_ldr_ui(d, rs)
          #define jit_ldr_ul(d, rs)
          #define jit_ldr_us(d, rs)
          #define jit_sti_c(id, rs)
          #define jit_sti_i(id, rs)
          #define jit_sti_s(id, rs)
          #define jit_str_c(rd, rs)
          #define jit_str_i(rd, rs)
          #define jit_str_s(rd, rs)

Synonyms--don't define them:
          #define jit_addi_p(d, rs, is)
          #define jit_addi_ui(d, rs, is)
          #define jit_addi_ul(d, rs, is)
          #define jit_addr_p(d, s1, s2)
          #define jit_addr_ui(d, s1, s2)
          #define jit_addr_ul(d, s1, s2)
          #define jit_andi_ui(d, rs, is)
          #define jit_andi_ul(d, rs, is)
          #define jit_andr_ui(d, s1, s2)
          #define jit_andr_ul(d, s1, s2)
          #define jit_beqi_p(label, rs, is)
          #define jit_beqi_ui(label, rs, is)
          #define jit_beqi_ul(label, rs, is)
          #define jit_beqr_p(label, s1, s2)
          #define jit_beqr_ui(label, s1, s2)
          #define jit_beqr_ul(label, s1, s2)
          #define jit_bmci_ui(label, rs, is)
          #define jit_bmci_ul(label, rs, is)
          #define jit_bmcr_ui(label, s1, s2)
          #define jit_bmcr_ul(label, s1, s2)
          #define jit_bmsi_ui(label, rs, is)
          #define jit_bmsi_ul(label, rs, is)
          #define jit_bmsr_ui(label, s1, s2)
          #define jit_bmsr_ul(label, s1, s2)
          #define jit_bgei_p(label, rs, is)
          #define jit_bger_p(label, s1, s2)
          #define jit_bgti_p(label, rs, is)
          #define jit_bgtr_p(label, s1, s2)
          #define jit_blei_p(label, rs, is)
          #define jit_bler_p(label, s1, s2)
          #define jit_blti_p(label, rs, is)
          #define jit_bltr_p(label, s1, s2)
          #define jit_bnei_p(label, rs, is)
          #define jit_bnei_ui(label, rs, is)
          #define jit_bnei_ul(label, rs, is)
          #define jit_bner_p(label, s1, s2)
          #define jit_bner_ui(label, s1, s2)
          #define jit_bner_ul(label, s1, s2)
          #define jit_eqi_p(d, rs, is)
          #define jit_eqi_ui(d, rs, is)
          #define jit_eqi_ul(d, rs, is)
          #define jit_eqr_p(d, s1, s2)
          #define jit_eqr_ui(d, s1, s2)
          #define jit_eqr_ul(d, s1, s2)
          #define jit_extr_uc_i(d, rs)
          #define jit_extr_uc_ui(d, rs)
          #define jit_extr_ui_l(d, rs)
          #define jit_extr_ui_l(d, rs)
          #define jit_extr_ui_ul(d, rs)
          #define jit_extr_ui_ul(d, rs)
          #define jit_extr_us_i(d, rs)
          #define jit_extr_us_ui(d, rs)
          #define jit_gei_p(d, rs, is)
          #define jit_ger_p(d, s1, s2)
          #define jit_gti_p(d, rs, is)
          #define jit_gtr_p(d, s1, s2)
          #define jit_ldr_p(d, rs)
          #define jit_ldi_p(d, is)
          #define jit_ldxi_p(d, rs, is)
          #define jit_ldxr_p(d, s1, s2)
          #define jit_lei_p(d, rs, is)
          #define jit_ler_p(d, s1, s2)
          #define jit_lshi_ui(d, rs, is)
          #define jit_lshi_ul(d, rs, is)
          #define jit_lshr_ui(d, s1, s2)
          #define jit_lshr_ul(d, s1, s2)
          #define jit_lti_p(d, rs, is)
          #define jit_ltr_p(d, s1, s2)
          #define jit_movi_p(d, is)
          #define jit_movi_ui(d, rs)
          #define jit_movi_ul(d, rs)
          #define jit_movr_p(d, rs)
          #define jit_movr_ui(d, rs)
          #define jit_movr_ul(d, rs)
          #define jit_nei_p(d, rs, is)
          #define jit_nei_ui(d, rs, is)
          #define jit_nei_ul(d, rs, is)
          #define jit_ner_p(d, s1, s2)
          #define jit_ner_ui(d, s1, s2)
          #define jit_ner_ul(d, s1, s2)
          #define jit_hton_ui(d, rs)
          #define jit_hton_us(d, rs)
          #define jit_ori_ui(d, rs, is)
          #define jit_ori_ul(d, rs, is)
          #define jit_orr_ui(d, s1, s2)
          #define jit_orr_ul(d, s1, s2)
          #define jit_pop_ui(rs)
          #define jit_pop_ul(rs)
          #define jit_push_ui(rs)
          #define jit_push_ul(rs)
          #define jit_pusharg_c(rs)
          #define jit_pusharg_p(rs)
          #define jit_pusharg_s(rs)
          #define jit_pusharg_uc(rs)
          #define jit_pusharg_ui(rs)
          #define jit_pusharg_ul(rs)
          #define jit_pusharg_us(rs)
          #define jit_retval_c(rd)
          #define jit_retval_p(rd)
          #define jit_retval_s(rd)
          #define jit_retval_uc(rd)
          #define jit_retval_ui(rd)
          #define jit_retval_ul(rd)
          #define jit_retval_us(rd)
          #define jit_rsbi_ui(d, rs, is)
          #define jit_rsbi_ul(d, rs, is)
          #define jit_rsbr_ui(d, s1, s2)
          #define jit_rsbr_ul(d, s1, s2)
          #define jit_sti_p(d, is)
          #define jit_sti_uc(d, is)
          #define jit_sti_ui(d, is)
          #define jit_sti_ul(d, is)
          #define jit_sti_us(d, is)
          #define jit_str_p(d, rs)
          #define jit_str_uc(d, rs)
          #define jit_str_ui(d, rs)
          #define jit_str_ul(d, rs)
          #define jit_str_us(d, rs)
          #define jit_stxi_p(d, rs, is)
          #define jit_stxi_uc(d, rs, is)
          #define jit_stxi_ui(d, rs, is)
          #define jit_stxi_ul(d, rs, is)
          #define jit_stxi_us(d, rs, is)
          #define jit_stxr_p(d, s1, s2)
          #define jit_stxr_uc(d, s1, s2)
          #define jit_stxr_ui(d, s1, s2)
          #define jit_stxr_ul(d, s1, s2)
          #define jit_stxr_us(d, s1, s2)
          #define jit_subi_p(d, rs, is)
          #define jit_subi_ui(d, rs, is)
          #define jit_subi_ul(d, rs, is)
          #define jit_subr_p(d, s1, s2)
          #define jit_subr_ui(d, s1, s2)
          #define jit_subr_ul(d, s1, s2)
          #define jit_xori_ui(d, rs, is)
          #define jit_xori_ul(d, rs, is)
          #define jit_xorr_ui(d, s1, s2)
          #define jit_xorr_ul(d, s1, s2)

Shortcuts--don't define them:
          #define jit_notr_c(d, rs)
          #define jit_notr_i(d, rs)
          #define jit_notr_l(d, rs)
          #define jit_notr_s(d, rs)
          #define jit_notr_uc(d, rs)
          #define jit_notr_ui(d, rs)
          #define jit_notr_ul(d, rs)
          #define jit_notr_us(d, rs)
          #define jit_rsbr_i(d, s1, s2)
          #define jit_rsbr_l(d, s1, s2)
          #define jit_subi_i(d, rs, is)
          #define jit_subi_l(d, rs, is)

Mandatory if sizeof(long) != sizeof(int)--don't define them on other systems:
          #define jit_addi_l(d, rs, is)
          #define jit_addr_l(d, s1, s2)
          #define jit_andi_l(d, rs, is)
          #define jit_andr_l(d, s1, s2)
          #define jit_beqi_l(label, rs, is)
          #define jit_beqr_l(label, s1, s2)
          #define jit_bgei_l(label, rs, is)
          #define jit_bgei_ul(label, rs, is)
          #define jit_bger_l(label, s1, s2)
          #define jit_bger_ul(label, s1, s2)
          #define jit_bgti_l(label, rs, is)
          #define jit_bgti_ul(label, rs, is)
          #define jit_bgtr_l(label, s1, s2)
          #define jit_bgtr_ul(label, s1, s2)
          #define jit_blei_l(label, rs, is)
          #define jit_blei_ul(label, rs, is)
          #define jit_bler_l(label, s1, s2)
          #define jit_bler_ul(label, s1, s2)
          #define jit_blti_l(label, rs, is)
          #define jit_blti_ul(label, rs, is)
          #define jit_bltr_l(label, s1, s2)
          #define jit_bltr_ul(label, s1, s2)
          #define jit_bosubi_l(label, rs, is)
          #define jit_bosubi_ul(label, rs, is)
          #define jit_bosubr_l(label, s1, s2)
          #define jit_bosubr_ul(label, s1, s2)
          #define jit_boaddi_l(label, rs, is)
          #define jit_boaddi_ul(label, rs, is)
          #define jit_boaddr_l(label, s1, s2)
          #define jit_boaddr_ul(label, s1, s2)
          #define jit_bmci_l(label, rs, is)
          #define jit_bmcr_l(label, s1, s2)
          #define jit_bmsi_l(label, rs, is)
          #define jit_bmsr_l(label, s1, s2)
          #define jit_bnei_l(label, rs, is)
          #define jit_bner_l(label, s1, s2)
          #define jit_divi_l(d, rs, is)
          #define jit_divi_ul(d, rs, is)
          #define jit_divr_l(d, s1, s2)
          #define jit_divr_ul(d, s1, s2)
          #define jit_eqi_l(d, rs, is)
          #define jit_eqr_l(d, s1, s2)
          #define jit_gei_l(d, rs, is)
          #define jit_gei_ul(d, rs, is)
          #define jit_ger_l(d, s1, s2)
          #define jit_ger_ul(d, s1, s2)
          #define jit_gti_l(d, rs, is)
          #define jit_gti_ul(d, rs, is)
          #define jit_gtr_l(d, s1, s2)
          #define jit_gtr_ul(d, s1, s2)
          #define jit_hmuli_l(d, rs, is)
          #define jit_hmuli_ul(d, rs, is)
          #define jit_hmulr_l(d, s1, s2)
          #define jit_hmulr_ul(d, s1, s2)
          #define jit_ldi_l(d, is)
          #define jit_ldi_ui(d, is)
          #define jit_ldr_l(d, rs)
          #define jit_ldr_ui(d, rs)
          #define jit_ldxi_l(d, rs, is)
          #define jit_ldxi_ui(d, rs, is)
          #define jit_ldxi_ul(d, rs, is)
          #define jit_ldxr_l(d, s1, s2)
          #define jit_ldxr_ui(d, s1, s2)
          #define jit_ldxr_ul(d, s1, s2)
          #define jit_lei_l(d, rs, is)
          #define jit_lei_ul(d, rs, is)
          #define jit_ler_l(d, s1, s2)
          #define jit_ler_ul(d, s1, s2)
          #define jit_lshi_l(d, rs, is)
          #define jit_lshr_l(d, s1, s2)
          #define jit_lti_l(d, rs, is)
          #define jit_lti_ul(d, rs, is)
          #define jit_ltr_l(d, s1, s2)
          #define jit_ltr_ul(d, s1, s2)
          #define jit_modi_l(d, rs, is)
          #define jit_modi_ul(d, rs, is)
          #define jit_modr_l(d, s1, s2)
          #define jit_modr_ul(d, s1, s2)
          #define jit_movi_l(d, rs)
          #define jit_movr_l(d, rs)
          #define jit_muli_l(d, rs, is)
          #define jit_muli_ul(d, rs, is)
          #define jit_mulr_l(d, s1, s2)
          #define jit_mulr_ul(d, s1, s2)
          #define jit_nei_l(d, rs, is)
          #define jit_ner_l(d, s1, s2)
          #define jit_ori_l(d, rs, is)
          #define jit_orr_l(d, s1, s2)
          #define jit_pop_l(rs)
          #define jit_push_l(rs)
          #define jit_pusharg_l(rs)
          #define jit_retval_l(rd)
          #define jit_rshi_l(d, rs, is)
          #define jit_rshi_ul(d, rs, is)
          #define jit_rshr_l(d, s1, s2)
          #define jit_rshr_ul(d, s1, s2)
          #define jit_sti_l(d, is)
          #define jit_str_l(d, rs)
          #define jit_stxi_l(d, rs, is)
          #define jit_stxr_l(d, s1, s2)
          #define jit_subr_l(d, s1, s2)
          #define jit_xori_l(d, rs, is)
          #define jit_xorr_l(d, s1, s2)


File: lightning.info,  Node: Standard functions,  Next: Floating-point macros,  Prev: Standard macros,  Up: Porting GNU lightning

More complex tasks in the platform-independent layer
====================================================

   There is actually a single function that you *must* define in the
`funcs-SUFFIX.h' file, that is, `jit_flush_code'.

   As explained in *Note Generating code at run-time: GNU lightning
macros, its purpose is to flush part of the processor's instruction
cache (usually the part of memory that contains the generated code),
avoiding the processor executing bogus data that it happens to find in
the cache.  The `jit_flush_code' function takes the first and the last
address to flush.

   On many processors (for example, the x86 and the all the processors
in the 68k family up to the 68030), it is not even necessary to flush
the cache.  In this case, the contents of the file will simply be

     #ifndef __lightning_funcs_h
     #define __lightning_funcs_h
     
     #define jit_flush_code(dest, end)
     
     #endif /* __lightning_core_h */

   On other processors, flushing the cache is necessary for proper
behavior of the program; in this case, the file will contain a proper
definition of the function.  However, we must make yet another
distinction.

   On some processors, flushing the cache is obtained through a call to
the operating system or to the C run-time library.  In this case, the
definition of `jit_flush_code' will be very simple: two examples are
the Alpha and the 68040. For the Alpha the code will be:
     #define jit_flush_code(dest, end) \
             __asm__ __volatile__("call_pal 0x86");

and, for the Motorola
     #define jit_flush_code(start, end) \
             __clear_cache((start), (end))

   As you can see, the Alpha does not even need to pass the start and
end address to the function.  It is good practice to protect usage of
the GNU CC-specific `__asm__' directive by relying on the preprocessor.
For example:

     #if !defined(__GNUC__) && !defined(__GNUG__)
     #error Go get GNU C, I do not know how to flush the cache
     #error with this compiler.
     #else
     #define jit_flush_code(dest, end) \
             __asm__ __volatile__("call_pal 0x86");
     #endif

   GNU lightning's configuration process tries to compile a dummy file
that includes `lightning.h', and gives a warning if there are problem
with the compiler that is installed on the system.

   In more complex cases, you'll need to write a full-fledged function.
Don't forget to make it `static', otherwise you'll have problems
linking programs that include `lightning.h' multiple times. An example,
taken from the `funcs-ppc.h' file, is:

     #ifndef __lightning_funcs_h
     #define __lightning_funcs_h
     
     #if !defined(__GNUC__) && !defined(__GNUG__)
     #error Go get GNU C, I do not know how to flush the cache
     #error with this compiler.
     #else
     static void
     jit_flush_code(start, end)
          void       *start;
          void       *end;
     {
       register char *dest = start;
     
       for (; dest <= end; dest += SIZEOF_CHAR_P)
         __asm__ __volatile__
           ("dcbst 0,%0; sync; icbi 0,%0; isync"::"r"(dest));
     }
     #endif
     
     #endif /* __lightning_funcs_h */

   The `funcs-SUFFIX.h' file is also the right place to put helper
functions that do complex tasks for the `core-SUFFIX.h' file.  For
example, the PowerPC assembler defines `jit_prolog' as a function and
puts it in that file (for more information, *note Implementing the
ABI::).  Take special care when defining such a function, as explained
in *Note Reentrant usage of GNU lightning: Reentrancy.


File: lightning.info,  Node: Floating-point macros,  Prev: Standard functions,  Up: Porting GNU lightning

Implementing macros for floating point
======================================


File: lightning.info,  Node: Future,  Next: Acknowledgements,  Prev: Porting GNU lightning,  Up: Top

The future of GNU lightning
***************************

   Presented below is the set of tasks that I feel need to be performed
to make GNU lightning a more fully functional, viable system.  They are
presented in no particular order.  I would _very much_ welcome any
volunteers who would like to help with the implementation of one or
more of these tasks.  Please write to me, Paolo Bonzini, at
<bonzini@gnu.org> if you are interested in adding your efforts to the
GNU lightning project.

   Tasks:
   * The most important task to make GNU lightning more widely usable
     is to retarget it.  Although currently supported architectures
     (x86, SPARC, PowerPC) are certainly some of the most widely used,
     GNU lightning could be ported to others--namely, the Alpha and
     MIPS architectures.

   * Another interesting task is to allow the instruction stream to grow
     dynamically.  This is a problem because not all architectures allow
     to write position independent code.(1)

   * Optimize leaf procedures on the SPARC.  This involves using the
     output registers (`%oX') instead of the local registers (`%lX')
     when writing leaf procedures;  the problem is, leaf procedures
     also receive parameters in the output registers, so they would be
     overwritten by write accesses to general-purpose registers.

   ---------- Footnotes ----------

   (1) The x86's absolute jumps, for example, are actually slow
indirect jumps, and need a register.


File: lightning.info,  Node: Acknowledgements,  Prev: Future,  Up: Top

Acknowledgements
****************

   As far as I know, the first general-purpose portable dynamic code
generator is DCG, by Dawson R. Engler and T. A. Proebsting.  Further
work by Dawson R. Engler resulted in the VCODE system; unlike DCG,
VCODE used no intermediate representation and directly inspired GNU
lightning.

   Thanks go to Ian Piumarta, who kindly accepted to release his own
program CCG under the GNU General Public License, thereby allowing GNU
lightning to use the run-time assemblers he had wrote for CCG.  CCG
provides a way of dynamically assemble programs written in the
underlying architecture's assembly language.  So it is not portable,
yet very interesting.

   I also thank Steve Byrne for writing GNU Smalltalk, since GNU
lightning was first developed as a tool to be used in GNU Smalltalk's
dynamic translator from bytecodes to native code.


